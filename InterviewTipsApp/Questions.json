[
    {
        "id": "1",
        "question": "Назовите главные принципы ООП.",
        "answer": "Инкапсуляция, \n\nНаследование, \n\nПолиморфизм, \n\nАбстракция",
        "theme" : "ООП"
    },
    {
        "id": "2",
        "question": "Что такое наследование, инкапсуляция, абстракция, полиморфизм? Приведите примеры (желательно по собственному опыту).",
        "answer": "Наследование: Это принцип ООП, который позволяет создавать новые классы на основе существующих. Новый класс, называемый подклассом или производным классом, наследует свойства и методы базового класса. Например, если у вас есть класс \"Автомобиль\", вы можете создать подклассы \"Седан\" и \"Внедорожник\", которые наследуют общие характеристики, такие как \"модель\" и \"год выпуска\".\n\nИнкапсуляция: Это механизм, который позволяет скрыть детали реализации и предоставить интерфейс для взаимодействия с объектом. Примером может быть класс \"Банковский счет\", который скрывает баланс и предоставляет методы для депозита и снятия средств.\n\nАбстракция: Это процесс выделения ключевых характеристик объекта и игнорирования деталей, несущественных для решаемой задачи. Например, в игре симуляции авиации абстракция может представлять самолет как объект с характеристиками \"скорость\", \"высота\" и \"направление\", игнорируя множество механических и физических деталей.\n\nПолиморфизм: Это способность объектов разных классов реагировать на одинаковые методы вызова. Примером может быть использование одного и того же метода \"открыть\" для разных типов файлов, таких как текстовый файл или изображение, и каждый тип файла реализует этот метод по-своему.\n\nЭти принципы позволяют разрабатывать более гибкие, понятные и поддерживаемые программы.",
        "theme" : "ООП"
    },
    {
        "id": "3",
        "question": "Какая разница между классом и структурой?",
        "answer": "У классов есть несколько дополнительных характеристик, которых нет у структур:\n• Классы могут наследоваться друг от друга\n• Классы могут быть деинициализированы\n• Классы поставляются со встроенным понятием идентичности, потому что они являются ссылочными типами.\n\nС помощью оператора идентичности === вы можете проверить, ссылаются ли два экземпляра класса на один и тот же объект.\n\nНаследование является наиболее важным различием между классом и структурой. С помощью классов вы можете четко определить родительско-дочернюю связь между подклассом и суперклассом. По умолчанию Apple рекомендует использовать структуры.\n\nСтруктуры также полезны в следующих сценариях:\n1. Используйте структуры для простых типов данных. Воспринимайте их как простые базы данных, которые вы можете использовать в своем коде. Поскольку они четко определены и часто не нуждаются в сложных отношениях между объектами.\n2. В многопоточной среде, например, с подключением к базе данных в другом потоке, структуры более безопасны и могут быть безопасно скопированы из одного потока в другой. Классы не имеют присущей им безопасности, если только они не намеренно сделаны поточно-ориентированными.\n3. Когда свойства структуры в основном являются значимыми типами, например String, имеет смысл обернуть их в структуру вместо класса.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "4",
        "question": "К каким типам (по доступу) относятся классы, структуры и перечисляемые типы?",
        "answer": "Классы и структуры могут быть public, internal или private. Перечисляемые типы могут быть также public, internal или private.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "5",
        "question": "Назовите главные классы/типы для работы с коллекциями (Swift).",
        "answer": "Главные классы/типы для работы с коллекциями в Swift включают Array, Set, Dictionary и Tuple.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "6",
        "question": "Как создать базовый класс в Swift?",
        "answer": "Для создания базового класса в Swift, вы создаете класс и другие классы могут наследоваться от него.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "7",
        "question": "Как запретить наследование класса?",
        "answer": "В Swift, чтобы запретить наследование класса, вы можете использовать ключевое слово final перед объявлением класса. Когда класс объявлен как final, он не может быть унаследован другими классами.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "8",
        "question": "Привести пример класса/структуры из библиотеки Swift/SwiftUI.",
        "answer": "Примеры классов/структур из библиотек Swift/SwiftUI включают в себя:\nSwiftUI: View – это протокол.\nSwift: Text – структура.\nUIKit: UIViewController – класс, UILabel – структура.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "9",
        "question": "Какой поток приложения следует использовать для использования классов UIKit?",
        "answer": "Для работы с классами UIKit следует использовать главный поток приложения.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "10",
        "question": "Можно ли переопределить методы класса A в классе B?",
        "answer": "Да, вы можете переопределить методы класса A в классе B при условии, что метод в классе A отмечен модификатором доступа open, public или internal, и класс B является подклассом класса A.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "11",
        "question": "Какой класс вы бы использовали для перечисления файлов в каталоге?",
        "answer": "Для перечисления файлов в каталоге в Swift, вы можете использовать класс FileManager из Foundation.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "12",
        "question": "Какой класс вы бы использовали для воспроизведения пользовательского звука в вашем приложении?",
        "answer": "Для воспроизведения пользовательского звука в приложении на платформе iOS, вы можете использовать класс AVAudioPlayer из библиотеки AVFoundation.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "13",
        "question": "Для чего предназначены размерные классы (size classes)?",
        "answer": "Размерные классы (Size Classes) предназначены для адаптации пользовательского интерфейса в приложении к различным размерам экранов и устройствам в iOS. Они позволяют разработчикам создавать адаптивные пользовательские интерфейсы, которые могут оптимально отображаться как на больших iPad-экранах, так и на меньших iPhone-экранах.",
        "theme" : "Классы и структуры"
    },
    {
        "id": "14",
        "question": "Что такое Closure?",
        "answer": "Closure - это блоки кода, которые могут быть многократно использованы, автономные блоки функциональности, которые можно передавать и использовать в вашем коде или блок кода, который вы можете присвоить переменной. Затем вы можете передать его в своем коде, например, в другую функцию.",
        "theme" : "Замыкания"
    },
    {
        "id": "15",
        "question": "Что такое (autoclosure) автозамыкание в Swift? Как и когда его следует использовать?",
        "answer": "(Autoclosure) Автозамыкание в Swift - это особый тип замыкания, который автоматически оборачивает выражение в замыкание без явного использования фигурных скобок {} или ключевого слова in. Автозамыкания обычно используются с аргументами, которые должны быть вычислены только при вызове функции, и они позволяют задерживать вычисление этих аргументов до момента вызова функции.",
        "theme" : "Замыкания"
    },
    {
        "id": "16",
        "question": "Замыкания (closures) являются типами значений или ссылочными типами?",
        "answer": "В языке программирования Swift замыкания (closures) являются типами значений (value types). Это означает, что замыкания передаются и копируются как значения.",
        "theme" : "Замыкания"
    },
    {
        "id": "17",
        "question": "Escaping Closures",
        "answer": "Escaping Closures - это замыкание в Swift, которое передается как аргумент в функцию, но может быть вызвано или сохранено для выполнения после завершения этой функции. Важной характеристикой замыканий с отложенным выполнением является то, что они продолжают существовать и выполняться за пределами области видимости, в которой были переданы в функцию.",
        "theme" : "Замыкания"
    },
    {
        "id": "18",
        "question": "В чем разница между замыканием, выходящим за пределы текущей области видимости (escaping closure) и не выходящим за пределы (non-escaping closure)?",
        "answer": "Без префикса @escaping замыкание по умолчанию не является сбегающим, и его жизненный цикл заканчивается вместе с областью действия функции.",
        "theme" : "Замыкания"
    },
    {
        "id": "19",
        "question": "Что такое паттерн проектирования (design pattern)?",
        "answer": "Паттерн проектирования (design pattern) - это повторяемое решение для типичных проблем, возникающих при проектировании программного обеспечения. Примеры паттернов включают в себя 'Одиночка' (Singleton), 'Фабричный метод' (Factory Method), 'Строитель' (Builder), 'Наблюдатель' (Observer), 'Адаптер' (Adapter), 'Стратегия' (Strategy) и многие другие.",
        "theme" : "Паттерны проектирования"
    },
    {
        "id": "20",
        "question": "Можете ли вы привести примеры, где шаблон 'Синглтон' (Singleton) может быть хорошей идеей?",
        "answer": "Шаблон 'Синглтон' (Singleton) может быть хорошей идеей в случаях, когда вам нужно обеспечить существование единственного экземпляра класса во всем приложении. Примеры включают 'Settings Manager' (менеджер настроек), 'Networking Manager' (менеджер сетевых запросов), 'Authentication Manager' (менеджер аутентификации) и другие сценарии, где у вас должен быть единственный и глобальный доступ к функциональности данного класса.",
        "theme" : "Паттерны проектирования"
    },
    {
        "id": "21",
        "question": "Расскажите о Memory management в Swift: ARC и атрибуты.",
        "answer": "ARC - это механизм управления памятью, который автоматически отслеживает и управляет количеством ссылок на объекты. Он позволяет освобождать память, занятую объектами, когда на них больше нет активных ссылок, и это делает работу с памятью более безопасной и удобной.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "22",
        "question": "В чем разница между MRC и ARC?",
        "answer": "MRC - это ручное управление памятью и использовалось в Objective-C. ARC - автоматическое управление памятью и используется в Swift. Основная разница заключается в том, что MRC требует ручного управления памятью с использованием методов retain, release и autorelease, в то время как ARC автоматически отслеживает и управляет памятью за вас.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "23",
        "question": "Что такое многопоточность (Multithreading)?",
        "answer": "Многопоточность - это подход, при котором приложение выполняет несколько потоков (threads) кода параллельно. Каждый поток может быть рассмотрен как независимая последовательность выполнения инструкций, которая работает внутри процесса приложения.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "24",
        "question": "Объясните, что такое Grand Central Dispatch (GCD) в iOS?",
        "answer": "Grand Central Dispatch (GCD) - это механизм для работы с потоками и управления параллельными задачами в iOS. Он позволяет разработчикам создавать асинхронные задачи и управлять ими без необходимости явного создания и управления потоками.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "25",
        "question": "Как запустить задачу в фоновом потоке с помощью GCD?",
        "answer": "DispatchQueue.global(qos: .background).async { /* Ваш код для выполнения в фоновом потоке */ }",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "27",
        "question": "Какие бывают Queue? ",
        "answer": "Очереди бывают двух типов: серийные (serial) и параллельные (concurrent). Серийные очереди выполняют задачи последовательно, в то время как параллельные могут выполнять их параллельно.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "28",
        "question": "Методы для работы с очередями",
        "answer": "Для работы с очередями в GCD вы можете создавать очереди, запускать задачи на очереди с помощью методов async и sync, определять приоритет задачи с помощью qos (Quality of Service), а также отменять задачи при необходимости.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "29",
        "question": "Проблемы многопоточности",
        "answer": "Проблемы многопоточности включают в себя состояние гонки (Race Condition), дедлок (Deadlock) и другие проблемы, связанные с параллельным выполнением кода на нескольких потоках.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "30",
        "question": "Каковы инструменты выполнения задач на нескольких потоках в iOS?",
        "answer": "Инструменты выполнения задач на нескольких потоках в iOS включают в себя Grand Central Dispatch (GCD), DispatchSemaphore, DispatchGroup и другие механизмы для работы с многопоточностью.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "31",
        "question": "Опишите ситуации, в которых появляются reference cycles, расскажите о предотвращении.",
        "answer": "Reference cycles (циклы ссылок) возникают, когда объекты ссылочно связаны таким образом, что счетчик ссылок на них никогда не достигает нуля, даже когда они больше не используются. Это может привести к утечке памяти, так как эти объекты не будут освобождены автоматически. Процесс предотвращения циклов ссылок обычно включает в себя использование слабых (weak) ссылок, безопасных (unowned) ссылок и блоков (closures).",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "32",
        "question": "Где в памяти хранятся экземпляры reference и value типов?",
        "answer": "Экземпляры value типов, такие как структуры (structs) и перечисления (enums), хранятся в стеке (stack) или внутри других объектов, которые хранятся в стеке. Экземпляры reference типов, такие как классы (classes), хранятся в куче (heap).",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "33",
        "question": "Назовите два типа структур данных для выделения памяти.",
        "answer": "Два основных типа структур данных для выделения памяти - это стек и куча.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "34",
        "question": "В чем разница между стековой и кучевой памятью?",
        "answer": "Разница между стековой и кучевой памятью заключается в семантике использования, скорости доступа, хранении данных, управлении памятью и области применения. Стек используется для хранения локальных переменных и управления вызовом функций, в то время как куча предназначена для долгосрочного хранения данных. Доступ к данным в стеке быстрее, чем в куче, и управление памятью автоматическое в стеке, в то время как в куче требуется сложное управление памятью. Стек обычно используется для короткоживущих объектов, а куча - для долгосрочного хранения данных и объектов reference типов.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "35",
        "question": "Value types - какие в Swift есть?",
        "answer": "В Swift существуют следующие value types: Structures (структуры), Enumerations (перечисления), Tuples (кортежи), Массивы (Arrays), Словари (Dictionaries) и Множества (Sets).",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "36",
        "question": "Что за тип данных array?",
        "answer": "Тип данных Array - это структура, которая в Swift обладает value semantic (значимой семантикой), что означает, что массив ведет себя как value тип, но его данные хранятся в куче (heap), а не в стеке (stack).",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "37",
        "question": "Reference типы - какие есть?",
        "answer": "Reference типы в Swift включают классы (classes), замыкания (closures) и другие типы, которые хранятся в куче (heap) и передаются по ссылке, а не по значению.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "38",
        "question": "В каком типе памяти хранятся reference типы?",
        "answer": "Reference типы, такие как классы и замыкания, хранятся в куче (heap).",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "39",
        "question": "Как система понимает, когда освобождать эти объекты, а когда выделять под них память?",
        "answer": "Память для объектов выделяется при их создании, и система следит за количеством активных ссылок на объекты с помощью механизма автоматического счетчика ссылок (ARC). Когда на объект больше нет активных ссылок, ARC автоматически освобождает память, выделенную под этот объект.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "40",
        "question": "Как освободить объект из памяти?",
        "answer": "Объект может быть освобожден из памяти путем удаления всех ссылок на него. Это можно сделать, присвоив nil ссылкам на объект или выходя из области видимости, где эти ссылки существовали.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "41",
        "question": "Когда освобождаются объекты из памяти?",
        "answer": "Объекты освобождаются из памяти в следующих случаях: 1. Выход из области видимости: Когда переменная, содержащая ссылку на объект, выходит из области видимости (например, заканчивается выполнение метода или функции), ARC уменьшает счетчик ссылок объекта. Если счетчик ссылок достигает нуля, объект освобождается. 2. Присваивание nil: Присваивание nil ссылке на объект приводит к уменьшению счетчика ссылок. Если после этого счетчик достигает нуля, объект освобождается.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "42",
        "question": "Какие типы ссылок бывают на объект (strong, weak, unowned), когда их нужно использовать и как часто и где их используют?",
        "answer": "Сильные ссылки (Strong References): Использование: Сильные ссылки - это тип ссылок, который используется по умолчанию при создании ссылок на объекты в Swift. Когда вы создаете переменную или константу, которая ссылается на объект, это создает сильную ссылку на этот объект. Когда использовать: Сильные ссылки используются тогда, когда объект должен существовать, пока есть активные сильные ссылки на него. \nСлабые ссылки (Weak References): Использование: Слабые ссылки создаются с помощью ключевого слова weak и используются для создания ссылок, которые не увеличивают счетчик ссылок объекта. Они позволяют объекту быть освобожденным, если на него есть только слабые ссылки. Когда использовать: Слабые ссылки часто используются в ситуациях, где есть возможность образования цикла ссылок, но одним из объектов в этом цикле должен быть освобожден. \nБезопасные ссылки (Unowned References): Использование: Безопасные ссылки создаются с помощью ключевого слова unowned и предполагают, что объект, на который указывает ссылка, всегда будет существовать. Они не увеличивают счетчик ссылок объекта. Когда использовать: Безопасные ссылки подходят для ситуаций, когда можно гарантировать, что объект будет существовать, и нет необходимости в сильной ссылке. unowned - по производительности быстрее, но может крашнуться, если будет нил",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "44",
        "question": "Что такое retain cycle?",
        "answer": "Это ситуации, когда объекты reference типа (например, экземпляры классов) образуют замкнутую цепочку взаимных ссылок, что приводит к утечке памяти. В цикле удержания каждый объект в цепочке ссылается на какой-то другой объект, и ни один из них не может быть освобожден сборщиком мусора или ARC, так как счетчики ссылок объектов никогда не достигают нуля.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "45",
        "question": "Как сделать так, чтобы удалить объект из памяти?",
        "answer": "Вы можете создать короткую область видимости, например, используя блок кода внутри фигурных скобок {}. Это позволяет объектам освобождаться при выходе за пределы области видимости. Также вы можете принудительно установить nil для опциональных ссылок, чтобы освободить объекты.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "46",
        "question": "При каких условиях используется weak в замыканиях?",
        "answer": "Weak используется в замыканиях, когда замыкание захватывает экземпляр класса (или другой объект reference типа), а этот экземпляр класса также имеет ссылку на это замыкание. Это помогает избежать цикла удержания (retain cycle) и утечки памяти.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "47",
        "question": "В чем разница между weak и unowned?",
        "answer": "Выбор между weak и unowned зависит от конкретных потребностей и дизайна вашего приложения. Если есть сомнения в существовании объекта, используйте weak, чтобы избежать аварийного завершения. Если вы уверены, что объект всегда существует, используйте unowned, чтобы уменьшить необходимость в разворачивании опциональных значений.",
        "theme" : "Управление памятью ARC"
    },
    {
        "id": "48",
        "question": "Какие знаете средства локального хранения данных?",
        "answer": "Core Data, UserDefaults, Realm, Keychain",
        "theme" : "Хранение данных iOS"
    },
    {
        "id": "49",
        "question": "Как осуществляется чтение/запись текстового (.txt) файла в iOS?",
        "answer": "Чтение и запись текстовых файлов в iOS осуществляется с использованием классов FileManager и String.",
        "theme" : "Хранение данных iOS"
    },
    {
        "id": "50",
        "question": "Что такое .plist файл? Какие типы данных можно хранить в таком файле?",
        "answer": "Файлы .plist (Property List) - это формат хранения данных в iOS и macOS, который используется для сохранения настроек, конфигурации и других структурированных данных",
        "theme" : "Хранение данных iOS"
    },
    {
        "id": "51",
        "question": "Для чего хорош UserDefaults? Для чего UserDefaults не подходит?",
        "answer": "UserDefaults - это механизм для хранения небольших объемов данных и настроек в приложении iOS и macOS. Он предоставляет простой способ сохранения и извлечения данных в форме ключ-значение (key-value). UserDefaults хорош для хранения настроек, пользовательских предпочтений и других небольших данных. Однако он не подходит для хранения больших объемов данных, таких как базы данных, и не предоставляет возможностей для сложных структур данных.",
        "theme" : "Хранение данных iOS"
    },
    {
        "id": "52",
        "question": "Расскажите о сетевых запросах и сериализации данных.",
        "answer": "Сетевые запросы включают использование URLSession, отправку HTTP-методов, обработку ответов от сервера. Сериализация данных включает в себя декодирование (Decoding) полученных данных в структуры или объекты, а также кодирование (Encoding) данных, которые будут отправлены на сервер. Этот процесс также включает в себя обработку ошибок, которые могут возникнуть во время сетевых операций.",
        "theme" : "Работа с сетью"
    },
    {
        "id": "53",
        "question": "Что такое JSON, XML?",
        "answer": "JSON (JavaScript Object Notation) и XML (eXtensible Markup Language) - это два распространенных формата данных, используемых для представления и обмена структурированными данными между системами. JSON представляет данные в виде пар ключ-значение, а XML использует разметку для описания данных.",
        "theme" : "Работа с сетью"
    },
    {
        "id": "54",
        "question": "Что такое REST?",
        "answer": "REST (Representational State Transfer) - это структурный стиль архитектуры для разработки сетевых приложений. Он представляет собой набор принципов и ограничений, которые спроектированы для создания масштабируемых и удобных в обслуживании веб-сервисов. REST является одним из наиболее популярных подходов к созданию API (Application Programming Interface) в веб-разработке.",
        "theme" : "Работа с сетью"
    },
    {
        "id": "55",
        "question": "Что такое async/await? (Swift 5.5)",
        "answer": "Это новая асинхронная модель, которая упрощает написание асинхронного кода и улучшает читаемость. async - ключевое слово, используемое для обозначения функций, выполняемых асинхронно. await - ключевое слово, используемое внутри асинхронных функций для ожидания завершения другой асинхронной операции.",
        "theme" : "Работа с сетью"
    },
    {
        "id": "56",
        "question": "Какие базовые структуры данных?",
        "answer": "Arrays, Sets, Dictionaries, Lists, Stacks",
        "theme" : "Коллекции"
    },
    {
        "id": "57",
        "question": "Какие коллекции есть в Swift, чем они отличаются?",
        "answer": "В Swift есть три основные коллекции: массив (Array), множество (Set) и словарь (Dictionary). Они отличаются по упорядоченности и уникальности элементов. Массив упорядочен и позволяет повторяющиеся элементы, множество неупорядочено и содержит уникальные элементы, а словарь предоставляет пары ключ-значение для быстрого доступа.",
        "theme" : "Коллекции"
    },
    {
        "id": "58",
        "question": "Что такое кортежи и в чем их польза?",
        "answer": "Кортежи (tuples) в Swift - это удобный способ объединения нескольких значений в одну составную структуру. Кортежи могут содержать элементы разных типов и предоставляют удобный способ работы с временными группами данных.",
        "theme" : "Коллекции"
    },
    {
        "id": "59",
        "question": "Какова временная сложность добавления элемента в начало массива?",
        "answer": "В Swift, добавление элемента в начало массива (с использованием метода insert(_:at:) или оператора array.insert(element, at: 0)) обычно имеет временную сложность O(n), где n - количество элементов в массиве. При этом каждый элемент массива, находящийся после добавленного элемента, должен быть смещен на одну позицию вправо, чтобы освободить место для нового элемента.",
        "theme" : "Коллекции"
    },
    {
        "id": "60",
        "question": "При использовании массивов, в чем разница между map() и compactMap()?",
        "answer": "Функция map() применяет преобразование к каждому элементу массива и возвращает массив результатов. compactMap() также применяет преобразование ко всем элементам массива, но автоматически удаляет (фильтрует) nil или Optional значения из результата. Это позволяет избежать Optional значений в итоговом массиве.",
        "theme" : "Коллекции"
    },
    {
        "id": "61",
        "question": "Можно ли положить в массив кложуры?",
        "answer": "Да, в Swift можно положить кложуры в массив. Кложуры - это объекты, и их можно хранить в массивах, передавать как аргументы функциям и возвращать из функций.",
        "theme" : "Коллекции"
    },
    {
        "id": "62",
        "question": "Что означает, когда говорят, что 'строки - это коллекции в Swift'?",
        "answer": "Это означает, что строки в Swift обладают набором сходных характеристик и функциональности с массивами. Они являются упорядоченными коллекциями, поддерживают итерацию по элементам, а также предоставляют методы и свойства, характерные для коллекций, такие как доступ по индексу и манипуляции с элементами.",
        "theme" : "Коллекции"
    },
    {
        "id": "63",
        "question": "Что мы можем использовать в словаре в качестве ключа?",
        "answer": "В словаре в Swift можно использовать элементы, которые соответствуют протоколу Hashable в качестве ключей. Это означает, что элементы должны иметь уникальное хеш-значение, которое используется для быстрого поиска и проверки уникальности элементов в словаре.",
        "theme" : "Коллекции"
    },
    {
        "id": "64",
        "question": "Что мы можем положить в множество (сет)?",
        "answer": "В множество (сет) в Swift можно положить элементы, которые соответствуют протоколу Hashable. Это позволяет сету хранить уникальные элементы и быстро проверять их уникальность с использованием хеш-значений.",
        "theme" : "Коллекции"
    },
    {
        "id": "65",
        "question": "Что такое перечисления (enumerations) или Enum в Swift?",
        "answer": "Перечисления (enum) в Swift - это тип данных, который ограничивает возможные значения переменной, предоставляя именованные кейсы.",
        "theme" : "Перечисления | Enum"
    },
    {
        "id": "66",
        "question": "Как в enum положить значение (associated value)?",
        "answer": "Для добавления ассоциированных значений в перечисление (enum) в Swift, вы определяете кейс с ассоциированными значениями, используя скобки (). Каждое ассоциированное значение имеет свой собственный тип. Например: case snowy(String, Int)",
        "theme" : "Перечисления | Enum"
    },
    {
        "id": "67",
        "question": "Какие особенности enum у Swift?",
        "answer": "Основные особенности перечислений (enum) в Swift включают именованные кейсы, которые ограничивают допустимые значения, а также возможность использования ассоциированных значений с кейсами, что позволяет хранить дополнительные данные в enum. Это делает enum более мощным и гибким средством для моделирования различных сценариев.",
        "theme" : "Перечисления | Enum"
    },
    {
        "id": "68",
        "question": "Что такое SwiftUI? Что такое модификатор? Каким типом данных является View?",
        "answer": "SwiftUI - это декларативный фреймворк для создания интерфейса. Модификаторы - это специальные методы, которые можно вызвать на View, чтобы изменить его поведение или внешний вид. View является протоколом.",
        "theme" : "UI"
    },
    {
        "id": "69",
        "question": "Что такое UIKit? Что такое Auto Layout? Из чего они состоят?",
        "answer": "UIKit - это фреймворк для создания пользовательского интерфейса в iOS. Auto Layout - это система размещения элементов интерфейса, которая позволяет создавать адаптивные и динамические макеты. Она состоит из Constraints (ограничений) и Autoresizing (автоподгонки).",
        "theme" : "UI"
    },
    {
        "id": "70",
        "question": "Каков жизненный цикл UIViewController?",
        "answer": "Жизненный цикл UIViewController включает следующие этапы: \nInitialization (Инициализация), \nloadView(), \nviewDidLoad(), \nviewWillAppear(_:), \nviewDidAppear(_:), \nUser Interaction, \nviewWillDisappear(_:), \nviewDidDisappear(_:), \nи deinit.",
        "theme" : "UI"
    },
    {
        "id": "71",
        "question": "Сравните frame vs bounds.",
        "answer": "frame - это свойство в SwiftUI, которое определяет размер и расположение вида относительно его родительского контейнера. bounds - это свойство в UIKit, которое определяет размер и координаты вида относительно его собственной координатной системы.",
        "theme" : "UI"
    },
    {
        "id": "72",
        "question": "Какие существуют методы для определения расположения элементов в UIView?",
        "answer": "Для определения расположения элементов в UIView можно использовать следующие методы и свойства: frame, bounds, center, layoutSubviews(), autoresizingMask и constraints.",
        "theme" : "UI"
    },
    {
        "id": "73",
        "question": "Что означают принципы проектирования KISS/DRY/YAGNI?",
        "answer": "\n1. KISS (Keep It Simple, Stupid): Принцип означает, что решения должны быть максимально простыми и ненавязчивыми. Не следует усложнять код или дизайн без необходимости. \n2. DRY (Don't Repeat Yourself): Принцип подразумевает, что каждый кусок информации или функциональности должен иметь единственное источника в коде. Избегайте дублирования кода. \n3. YAGNI (You Ain't Gonna Need It): Принцип советует не добавлять функциональность или компоненты, которые вам пока не нужны. Избегайте создания избыточных и сложных решений, предпочитая простоту.",
        "theme" : "SOLID"
    },
    {
        "id": "74",
        "question": "Что такое SOLID?",
        "answer": "SOLID - это акроним, представляющий пять основных принципов объектно-ориентированного проектирования и программирования: \n1. S - Single Responsibility Principle (Принцип единственной ответственности) \nКаждый класс должен иметь только одну причину для изменения. \n2. O - Open/Closed Principle (Принцип открытости/закрытости) \nПрограммные сущности (классы, модули и т. д.) должны быть открыты для расширения, но закрыты для модификации.\n3. L - Liskov Substitution Principle (Принцип подстановки Лисков) \nОбъекты подклассов должны быть способны заменять объекты суперкласса без нарушения корректности программы.\n4. I - Interface Segregation Principle (Принцип разделения интерфейса) \nКлиенты не должны зависеть от интерфейсов, которые они не используют. Интерфейсы должны быть маленькими и специфичными.\n5.D - Dependency Inversion Principle (Принцип инверсии зависимостей)\nМодули высшего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.",
        "theme" : "SOLID"
    },
    {
        "id": "75",
        "question": "Что такое клиент-серверная архитектура? В роли кого в этой архитектуре чаще всего выступает мобильное приложение?",
        "answer": "Клиент-серверная архитектура - это архитектурный подход, при котором система разделяется на две основные компоненты: клиенты (клиентские приложения) и серверы. Клиенты отправляют запросы на серверы, которые обрабатывают эти запросы и предоставляют соответствующие данные или услуги. В мобильных приложениях мобильное приложение обычно выступает в роли клиента, отправляя запросы на удаленные серверы для получения данных или выполнения действий.",
        "theme" : "Приложение"
    },
    {
        "id": "76",
        "question": "Как проверить работу программы в условиях плохого интернета?",
        "answer": "Для проверки работы программы в условиях плохого интернета, вы можете использовать инструменты, такие как 'Network Link Conditioner' (Симулятор медленного интернет-соединения) в Xcode. Этот инструмент позволяет эмулировать медленное или нестабильное интернет-соединение, чтобы оценить, как ваше приложение будет вести себя в таких условиях. Это полезно для тестирования производительности и надежности приложения при ограниченной пропускной способности сети или ненадежном соединении.",
        "theme" : "Приложение"
    },
    {
        "id": "77",
        "question": "Что такое iOS Application Lifecycle (жизненный цикл iOS-приложения)? В каких состояниях может находиться приложение в своем жизненном цикле? Как в нем отображаются переходы между разными состояниями?",
        "answer": "Жизненный цикл iOS-приложения - это последовательность состояний, через которые проходит приложение, начиная с момента запуска и завершая его закрытием. В iOS приложение может находиться в следующих состояниях: 1. Not Running (Не работает): Приложение не запущено или было завершено пользователем или системой. 2. Inactive (Неактивное): Приложение находится в фоновом режиме, но не активно. 3. Active (Активное): Приложение активно и открыто на экране. 4. Background (Фоновое): Приложение находится в фоновом режиме и не активно на экране, но продолжает выполнять некоторые задачи. 5. Suspended (Приостановленное): Приложение находится в фоновом режиме, но его выполнение приостановлено системой для экономии ресурсов. В этом состоянии приложение не выполняет код. Переходы между состояниями отображаются в ответе на события и действия пользователя. Например, приложение может перейти из состояния Inactive в Active, когда пользователь открывает его на экране. Из состояния Active в Background, когда пользователь сворачивает приложение, и так далее.",
        "theme" : "Приложение"
    },
    {
        "id": "78",
        "question": "Что такое идентификатор приложения и идентификатор пакета и почему они используются?",
        "answer": "Идентификатор приложения (App ID) и идентификатор пакета (Bundle Identifier) - это уникальные строки, используемые для идентификации и различия мобильных приложений в экосистеме iOS (и Android). Идентификатор приложения используется для взаимодействия с сервисами Apple, а идентификатор пакета определяет приложение в рамках конкретного проекта (Xcode проекта) и также определяет его уникальность в App Store.",
        "theme" : "Приложение"
    },
    {
        "id": "79",
        "question": "На каком из этапов жизненного цикла VC лучше устанавливать значения в лейбл?",
        "answer": "Наилучшим моментом для установки значений в лейбл обычно является метод 'viewDidLoad'. Этот метод вызывается после того, как интерфейс контроллера загружен, и это хорошее место для начальной настройки элементов интерфейса. В методе 'viewWillAppear' лучше избегать установки значений в лейбл, так как он может вызываться многократно при каждом появлении контроллера на экране.",
        "theme" : "Приложение"
    },
    {
        "id": "80",
        "question": "Есть ли отличия в работе с UI элементами между viewDidLoad и viewWillAppear? Меняются ли как-то сами элементы?",
        "answer": "Да, есть отличия между методами 'viewDidLoad' и 'viewWillAppear'. 'viewDidLoad' вызывается после загрузки интерфейса контроллера и является хорошим местом для начальной настройки элементов. 'viewWillAppear' вызывается перед тем, как контроллер появится на экране и может вызываться многократно, например, при возврате к контроллеру из другого экрана. Элементы интерфейса не меняются между этими методами, но в 'viewWillAppear' вы можете выполнить дополнительные действия перед отображением контроллера, например, обновить данные на экране. (написано в ГайдЛайнах, (нет гарантии, что фреймы проставляются во viewDidLoad))",
        "theme" : "Приложение"
    },
    {
        "id": "81",
        "question": "Что может работать в фоне?",
        "answer": "В фоновом режиме в iOS могут работать различные задачи и службы, такие как:\n1. Актуализация местоположения (Location Updates): Приложения могут получать обновления местоположения в фоне, что полезно для навигационных или геолокационных приложений.\n2. Push-уведомления: Прием и обработка push-уведомлений может происходить в фоновом режиме.\n3. Загрузка данных: Приложения могут продолжать загружать данные, даже если они не активны на экране.\n4. Воспроизведение аудио: Приложения для воспроизведения музыки или аудиокниг могут работать в фоновом режиме.",
        "theme" : "Приложение"
    },
    {
        "id": "82",
        "question": "Когда приходит push-уведомление, что происходит с приложением?",
        "answer": "При приеме push-уведомления приложение в целом не активируется, но уведомление может отобразиться пользователю, и пользователь может щелкнуть по уведомлению, чтобы открыть приложение. Если приложение уже запущено в фоновом режиме, оно может обработать уведомление и выполнить определенные действия. В противном случае приложение может быть активировано в фоновом режиме для обработки уведомления, но оно не появится на переднем плане. Это позволяет приложению реагировать на входящие уведомления без необходимости активации на экране.",
        "theme" : "Приложение"
    },
    {
        "id": "83",
        "question": "Что такое управление процессами (Process management) в iOS?",
        "answer": "Управление процессами в iOS - это механизм для управления запущенными приложениями и их ресурсами. Он включает в себя такие аспекты как запуск и завершение приложений, многозадачность, управление памятью, управление жизненным циклом приложения и управление энергопотреблением. iOS обеспечивает контроль над процессами, чтобы обеспечить стабильную и эффективную работу мобильных устройств.",
        "theme" : "Приложение"
    },
    {
        "id": "84",
        "question": "Укажите разницу между viewDidLoad и viewDidAppear.",
        "answer": "Разница между 'viewDidLoad' и 'viewDidAppear' заключается в их вызове и назначении:\n\n1. 'viewDidLoad' вызывается после загрузки представления в память и используется для инициализации элементов интерфейса, настройки данных и других подготовительных действий. Он вызывается один раз при первой загрузке представления.\n\n2. 'viewDidAppear' вызывается после того, как представление уже отображено на экране и видимо для пользователя. Этот метод может вызываться многократно, например, при возврате к представлению из другого экрана. 'viewDidAppear' используется для реагирования на отображение, выполнения действий, которые должны быть связаны с видимым экраном, и обновления данных на экране.",
        "theme" : "Приложение"
    },
    {
        "id": "85",
        "question": "Что такое optional? что это за тип и как он организован в swift?",
        "answer": "Optional - это специальный тип данных в Swift, который может представлять два возможных состояния: значение и отсутствие значения (nil). Он используется для обработки ситуаций, когда переменная может быть пустой. Под капотом Optional - это перечисление (enum) в Swift. Он имеет два кейса: .some, который содержит ассоциированное значение, и .none, который представляет отсутствие значения. Optional использует дженерики для хранения и обработки различных типов данных.",
        "theme" : "Опционалы Optionals"
    },
    {
        "id": "86",
        "question": "Чем отличаются опциональные типы от неопциональных? Как привести один тип к другому?",
        "answer": "Опциональные типы отличаются тем, что они могут содержать значение или отсутствие значения (nil). Опциональные типы объявляются с использованием вопросительного знака, например, 'Int?' или 'String?'. Для приведения неопционального типа к опциональному, можно использовать оператор приведения типа с добавлением вопросительного знака, например, 'let optionalInt: Int? = Int(someInt)'. Для приведения опционального типа к неопциональному, можно использовать оператор разворачивания, например, 'if let unwrappedInt = optionalInt { // использование unwrappedInt }'.",
        "theme" : "Опционалы Optionals"
    },
    {
        "id": "87",
        "question": "Что такое force unwrap?",
        "answer": "Force unwrap (или принудительное извлечение) - это операция в Swift, которая используется для явного извлечения значения из опциональной переменной, даже если она равна `nil`. Оператор для принудительного извлечения - это восклицательный знак `!`. Однако использование force unwrap может вызвать аварийное завершение приложения, если переменная действительно равна `nil`, поэтому его следует использовать осторожно и только тогда, когда вы уверены, что переменная содержит значение.",
        "theme" : "Опционалы Optionals"
    },
    {
        "id": "88",
        "question": "Что такое необязательная цепочка (Optional Chaining) ?",
        "answer": "Необязательная цепочка (Optional Chaining) - это механизм в Swift, который позволяет безопасно получать значения из опциональных переменных и вызывать методы, свойства и подсценарии объектов, даже если эти объекты равны nil. Если какой-либо объект в цепочке равен nil, операция будет просто возвращать nil, и не будет возникать аварийное завершение приложения.",
        "theme" : "Опционалы Optionals"
    },
    {
        "id": "89",
        "question": "Что такое опциональное связывание (optional binding) ?",
        "answer": "Опциональное связывание (optional binding) - это метод в Swift для безопасного извлечения и использования значений из опциональных переменных или опциональных объектов. Он использует ключевые слова if let или guard let для проверки, содержит ли опциональная переменная некоторое значение (не nil), и если да, то привязывает это значение к новой константе или переменной, которую можно использовать внутри блока условия.",
        "theme" : "Опционалы Optionals"
    },
    {
        "id": "90",
        "question": "Что такое CocoaPods? Как инициировать проект для использования CocoaPods?",
        "answer": "CocoaPods - это менеджер зависимостей для проектов на платформе iOS, который упрощает установку и управление сторонними библиотеками и фреймворками. Для инициации проекта для использования CocoaPods, выполните следующие шаги:\n1. Убедитесь, что у вас установлен CocoaPods в системе.\n2. Перейдите в каталог вашего проекта в терминале.\n3. Создайте файл Podfile, который будет содержать список ваших зависимостей.\n4. Запустите команду 'pod install' в каталоге проекта для установки зависимостей.\n5. Откройте проект в Xcode через файл .xcworkspace, который был создан CocoaPods.\nТеперь вы можете использовать сторонние библиотеки в вашем проекте.",
        "theme" : "Фреймворки и работа с ними"
    },
    {
        "id": "91",
        "question": "Что такое Swift Package Manager?",
        "answer": "Swift Package Manager (SPM) - это официальный инструмент для управления зависимостями и создания пакетов в языке программирования Swift. Он предоставляет средства для создания, распространения и управления библиотеками и фреймворками в Swift-проектах.",
        "theme" : "Фреймворки и работа с ними"
    },
    {
        "id": "92",
        "question": "Что такое podfile? Что туда записывается?",
        "answer": "Podfile - это файл конфигурации, используемый в CocoaPods для определения зависимостей и настроек вашего проекта. В него записывается список библиотек и фреймворков, которые вы хотите добавить в свой проект, а также указываются версии этих зависимостей.",
        "theme" : "Фреймворки и работа с ними"
    },
    {
        "id": "93",
        "question": "Что такое SpriteKit и что такое SceneKit?",
        "answer": "SpriteKit - это фреймворк от Apple для разработки 2D-графики, анимаций и игр на платформах iOS, macOS и tvOS. SceneKit - это фреймворк от Apple для разработки 3D-графики, трехмерных моделей и сцен в приложениях и играх для iOS и macOS.",
        "theme" : "Фреймворки и работа с ними"
    },
    {
        "id": "94",
        "question": "Как CloudKit отличается от Core Data?",
        "answer": "CloudKit ориентирован на работу с данными в облаке и синхронизацию между устройствами, в то время как Core Data предназначен для локального хранения и управления данными внутри приложения.",
        "theme" : "Фреймворки и работа с ними"
    },
    {
        "id": "95",
        "question": "Как SpriteKit отличается от SceneKit?",
        "answer": "Основное различие между ними заключается в типе графики, с которой они работают (2D в случае SpriteKit и 3D в случае SceneKit) и типе приложений, для которых они обычно используются.",
        "theme" : "Фреймворки и работа с ними"
    },
    {
        "id": "96",
        "question": "Что такое storyboards и xibs/nibs? Для чего их используют?",
        "answer": "Storyboards используются для создания интерфейса приложения с навигацией между экранами, позволяя разработчикам визуально проектировать и связывать различные экраны приложения. Storyboards обычно применяются для приложений с сложной навигацией и многочисленными экранами.\n\nXIBs (или NIBs) - это отдельные файлы интерфейса, которые используются для создания отдельных компонентов интерфейса, таких как пользовательские представления (custom views), ячейки таблиц (table view cells), элементы пользовательского интерфейса (UI elements) и другие компоненты. XIBs/NIBs позволяют создавать переиспользуемые компоненты, которые могут быть добавлены в разные части приложения. Они обычно применяются, когда нужно создать переиспользуемые компоненты интерфейса.",
        "theme" : "UIKIT"
    },
    {
        "id": "97",
        "question": "Как бы вы объяснили переходы UIKit (UIKit segues) новому разработчику iOS?",
        "answer": "Переходы UIKit (UIKit segues) - это способ управления навигацией между экранами в приложении iOS с использованием сценариев и визуального интерфейса в Interface Builder. Они позволяют связывать представления (View Controllers) и определять, как и когда пользователь переходит с одного экрана на другой. Вот короткое описание:\n1. Используют в Interface Builder: Переходы UIKit создаются и настраиваются в Interface Builder (часть Xcode), где вы можете визуально связывать элементы интерфейса между сценами.\n2. Разные виды переходов: UIKit поддерживает разные типы переходов, такие как Push, Modal, Popover и другие. Каждый тип имеет свои характеристики и применяется в разных сценариях.\n3. Сценарии навигации: Вы можете определить сценарии навигации, указывая, когда и какой переход должен быть выполнен. Например, переход на новый экран может произойти по нажатию кнопки или в ответ на событие.\n4. Передача данных: Переходы UIKit позволяют передавать данные между экранами. Это может быть полезно для передачи информации с одного экрана на другой.",
        "theme" : "UIKIT"
    },
    {
        "id": "98",
        "question": "Для чего предназначены идентификаторы в storyboard?",
        "answer": "Идентификаторы позволяют однозначно идентифицировать View Controllers в storyboard. Это особенно важно, когда вы хотите выполнить переход между экранами или настроить их параметры в коде.",
        "theme" : "UIKIT"
    },
    {
        "id": "99",
        "question": "Какие преимущества приносит использование дочерних контроллеров представлений (child view controllers)?",
        "answer": "Использование дочерних контроллеров представлений способствует лучшей организации и управлению пользовательским интерфейсом и кодом в приложениях для iOS.",
        "theme" : "UIKIT"
    },
    {
        "id": "100",
        "question": "В чем разница между @IBOutlet и @IBAction?",
        "answer": "@IBOutlet используется для связывания элементов интерфейса с кодом, а @IBAction - для связывания действий с методами обработки событий в коде.",
        "theme" : "UIKIT"
    },
    {
        "id": "101",
        "question": "В чем разница между UIImage и UIImageView?",
        "answer": "Основная разница заключается в том, что UIImage представляет само изображение и предоставляет методы для работы с ним, в то время как UIImageView предоставляет контейнер для отображения UIImage на экране.",
        "theme" : "UIKIT"
    },
    {
        "id": "102",
        "question": "Для чего служат идентификаторы повторного использования ячеек таблицы (reuse identifiers) в UITableView?",
        "answer": "Идентификаторы повторного использования в UITableView помогают оптимизировать работу с ячейками и повысить производительность таблицы.",
        "theme" : "UIKIT"
    },
    {
        "id": "103",
        "question": "Когда бы вы выбрали использовать UICollectionView вместо UITableView?",
        "answer": "UICollectionView предпочтителен при работе с более сложными макетами и когда нужно отображать данные в сетке, такие как фотографии, плитки, плитки с информацией. Он также обладает гибкостью в создании пользовательских ячеек с разной высотой и шириной, поддерживает анимации и пользовательские эффекты, а также горизонтальный скроллинг.",
        "theme" : "UIKIT"
    },
    {
        "id": "104",
        "question": "Какова функция якорей (anchors) в Auto Layout?",
        "answer": "Якоря (anchors) в Auto Layout упрощают работу с оформлением и позиционированием элементов интерфейса. Они позволяют создавать ограничения (constraints) в коде более наглядно и читаемо, улучшая гибкость и поддерживаемость Auto Layout.",
        "theme" : "UIKIT"
    },
    {
        "id": "105",
        "question": "Для чего предназначен IBDesignable?",
        "answer": "IBDesignable - это атрибут в Swift, который применяется к пользовательским элементам управления (например, подклассам UIView), чтобы их интерфейс можно было просматривать и настраивать непосредственно в редакторе интерфейса (Interface Builder) Xcode.",
        "theme" : "UIKIT"
    },
    {
        "id": "106",
        "question": "Для чего предназначен UIMenuController?",
        "answer": "UIMenuController в iOS предназначен для отображения контекстного меню (попап-меню) в ответ на длительное нажатие (или другие жесты) над элементами интерфейса, такими как текстовые поля, изображения и другие взаимодействующие объекты.",
        "theme" : "UIKIT"
    },
    {
        "id": "107",
        "question": "Как бы вы объяснили окружение (environment) в SwiftUI новому разработчику?",
        "answer": "В SwiftUI, окружение (environment) - это способ передачи и хранения значений и параметров, которые могут быть доступны в представлениях (Views) без явной передачи их через параметры функций или конструкторов.",
        "theme" : "SwiftUI"
    },
    {
        "id": "108",
        "question": "Что делает обертка свойства @Published?",
        "answer": "@Published в SwiftUI используется для создания наблюдаемого (observable) объекта, который автоматически оповещает представление о изменениях свойства. Когда свойство, помеченное @Published, изменяется, SwiftUI автоматически обновляет представление, которое зависит от этого свойства.",
        "theme" : "SwiftUI"
    },
    {
        "id": "109",
        "question": "Что делает обертка свойства @State?",
        "answer": "Обертка свойства @State в SwiftUI используется для создания изменяемого (mutable) состояния в представлении. Когда свойство помечено как @State, SwiftUI отслеживает его изменения и автоматически обновляет представление, в котором это свойство используется.",
        "theme" : "SwiftUI"
    },
    {
        "id": "110",
        "question": "В чем разница между инициализатором представления (view's initializer) и методом onAppear()?",
        "answer": "Таким образом, инициализатор представления используется для начальной настройки, а onAppear() - для реакции на появление представления на экране.",
        "theme" : "SwiftUI"
    },
    {
        "id": "111",
        "question": "Когда бы вы использовали @StateObject по сравнению с @ObservedObject?",
        "answer": "Вы используете @StateObject, когда хотите создать новый экземпляр класса внутри представления и иметь контроль над его жизненным циклом. Это полезно, когда представление является владельцем этого объекта и должно управлять его созданием и уничтожением.\n\nВы используете @ObservedObject, когда уже есть существующий экземпляр класса, созданный вне представления, и представление должно наблюдать за его изменениями. Это полезно, когда объект существует вне представления и должен быть общим между несколькими представлениями.",
        "theme" : "SwiftUI"
    },
    {
        "id": "112",
        "question": "Как бы вы создали программную навигацию в SwiftUI?",
        "answer": "NavigationView вместе с NavigationLink.",
        "theme" : "SwiftUI"
    },
    {
        "id": "113",
        "question": "Когда бы вы использовали GeometryReader?",
        "answer": "Получение информации о размерах экрана\nОпределение положения и размера представлений относительно других представлений",
        "theme" : "SwiftUI"
    },
    {
        "id": "114",
        "question": "Почему SwiftUI использует структуры для представлений (views)?",
        "answer": "Неизменяемость\nПроизводительность\nБезопасность потоков\nПростота и ясность кода",
        "theme" : "SwiftUI"
    },
    {
        "id": "115",
        "question": "int, bool, double - какой тип данных?",
        "answer": "Это Struct",
        "theme" : "Объявление свойств и функций"
    },
    {
        "id": "116",
        "question": "Чем отличается if let от guard let? Какие инструменты control flow у Swift?",
        "answer": "`if let` используется для проверки опционального значения и выполнения кода, если оно не является `nil`, оставляя возможность продолжения выполнения кода за пределами блока `if`. `guard let` также используется для проверки опционального значения, но в случае, если значение оказывается `nil`, он прерывает выполнение текущей функции или метода с помощью `return`, `break`, или `continue`. Инструменты управления потоком в Swift включают в себя if, else, switch, for-in, while, repeat-while, а также операторы break, continue, и операторы раннего выхода (return, throw).",
        "theme" : "Объявление свойств и функций"
    },
    {
        "id": "117",
        "question": "Что такое lazy var?",
        "answer": "lazy var - это способ отложенной инициализации свойства, которое инициализируется при первом доступе к нему и кэшируется для последующих обращений.",
        "theme" : "Объявление свойств и функций"
    },
    {
        "id": "118",
        "question": "Что такое функция? Как создать функцию в Swift? В чем разница между private и public функциями?",
        "answer": "Функция - это блок кода, который выполняет определенную задачу или операцию. В Swift функция объявляется с использованием ключевого слова func и может принимать параметры, выполнять операции и возвращать результат.\n\nprivate: Функция с модификатором доступа private видна и доступна только внутри того же исходного файла, в котором она была объявлена. Это наивысший уровень ограничения доступа.\npublic: Функция с модификатором доступа public видна и доступна из любого исходного файла или модуля в вашем проекте. Это наивысший уровень доступности функции для других частей вашего приложения.",
        "theme" : "Объявление свойств и функций"
    },
    {
        "id": "119",
        "question": "Для каких целей используются вычисляемые свойства (computed properties)?",
        "answer": "Вычисляемые свойства (computed properties) в Swift используются для предоставления кастомной логики при доступе к свойству. Они позволяют вам вычислять значение свойства на лету, вместо хранения его в памяти. Вычисляемые свойства позволяют более гибко управлять данными и предоставлять пользовательскую логику, не привязываясь к хранению фактических значений.",
        "theme" : "Объявление свойств и функций"
    },
    {
        "id": "120",
        "question": "что такое extension и для чего они нужны, к чему мы можем написать extension (к enum и struct)",
        "answer": "extension в Swift - это механизм, позволяющий добавлять новые функции и свойства к существующим типам данных, включая структуры, классы, перечисления и протоколы.",
        "theme" : "Расширения Extension"
    },
    {
        "id": "121",
        "question": "какие есть ограничения в extension",
        "answer": "Вы не можете добавить хранимые свойства в расширение существующего типа. Расширения могут содержать только вычисляемые свойства. Нельзя переопределять существующие методы, свойства или индексы в расширениях. Это ограничение означает, что вы не можете изменять поведение уже существующих членов типа.",
        "theme" : "Расширения Extension"
    },
    {
        "id": "122",
        "question": "можно ли объявить computed/stored property в extension",
        "answer": "computed-  можем / stored - нет",
        "theme" : "Расширения Extension"
    },
    {
        "id": "123",
        "question": "Что такое протокол и для чего он нужен?",
        "answer": "Протокол - это абстрактное описание методов и свойств, которые тип должен реализовать, чтобы соответствовать этому протоколу. Он нужен для обеспечения согласованности между типами и поддержки множественного наследования функциональности.",
        "theme" : "Протоколы Protocols"
    },
    {
        "id": "124",
        "question": "Может ли протокол быть унаследован от другого протокола?",
        "answer": "Да",
        "theme" : "Протоколы Protocols"
    },
    {
        "id": "125",
        "question": "Какой функционал предоставляет протокол Codable?",
        "answer": "Протокол Codable предоставляет функциональность для кодирования (сериализации) и декодирования (десериализации) данных в и из формата JSON или других форматов.",
        "theme" : "Протоколы Protocols"
    },
    {
        "id": "126",
        "question": "Что делает протокол CaseIterable?",
        "answer": "Протокол CaseIterable позволяет создавать коллекции всех значений перечисления, что полезно, например, для итерации по всем случаям перечисления.",
        "theme" : "Протоколы Protocols"
    },
    {
        "id": "127",
        "question": "какие протоколы связаны с хешбл? самые частые",
        "answer": "Hashable: Этот протокол позволяет типу быть сравниваемым и использоваться в хеш-таблицах и словарях. Equatable: Этот протокол используется для определения равенства двух объектов и часто связан с реализацией метода hashValue в сочетании с Hashable.",
        "theme" : "Протоколы Protocols"
    },
    {
        "id": "134",
        "question": "Какие есть способы передачи данных между контроллерами?",
        "answer": "1. Передача данных через свойства. 2. Использование делегатов. 3. Использование NotificationCenter. 4. Использование сегвеев (Segues). 5. Колбеки.",
        "theme" : "Контроллеры"
    },
    {
        "id": "135",
        "question": "какие есть виды навигационных контроллеров? (navigation tabbar)",
        "answer": "Виды навигационных контроллеров: 1. UINavigationController. 2. UITabBarController. 3. UISplitViewController.",
        "theme" : "Контроллеры"
    },
    {
        "id": "136",
        "question": "Каковы преимущества использования дочерних контроллеров представлений (child view controllers)?",
        "answer": "Преимущества использования дочерних контроллеров представлений: 1. Разделение логики. 2. Модульность. 3. Повторное использование. 4. Легкая замена.",
        "theme" : "Контроллеры"
    },
    {
        "id": "137",
        "question": "Что делает атрибут @main?",
        "answer": "Атрибут @main в Swift используется для указания точки входа (entry point) приложения. Он указывает, какой именно тип (класс) должен быть использован в качестве точки входа при запуске приложения.",
        "theme" : "Разное"
    },
    {
        "id": "138",
        "question": "Что делает синтаксис #available?",
        "answer": "Синтаксис #available используется для проверки доступности определенных API в разных версиях операционной системы. Например, 'if #available(iOS 15, *)' проверяет, доступны ли определенные функции или классы на устройствах с iOS 15 и более новыми версиями.",
        "theme" : "Разное"
    },
    {
        "id": "139",
        "question": "Что такое вариативная функция (variadic function)?",
        "answer": "Вариативная функция (variadic function) - это функция, которая принимает переменное количество аргументов одного и того же типа. В Swift, они объявляются с использованием многоточия '...' после типа аргумента, например, 'func sum(numbers: Int...) -> Int'. Вариативные функции полезны, когда количество аргументов может изменяться, и они обеспечивают гибкость при написании кода.",
        "theme" : "Разное"
    },
    {
        "id": "140",
        "question": "Когда бы вы использовали ключевое слово defer в Swift?",
        "answer": "Ключевое слово defer в Swift используется для создания блоков кода, которые выполняются непосредственно перед выходом из текущей области видимости (например, выходом из функции или блока кода). Основное назначение defer - это гарантировать выполнение определенных действий, даже если происходит ошибка или выход из блока.",
        "theme" : "Разное"
    },
    {
        "id": "141",
        "question": "В чем разница между try, try? и try! в Swift?",
        "answer": "Основная разница между ними заключается в способе обработки ошибок: try требует обработки ошибки с использованием do-catch, try? возвращает опциональное значение, а try! вызывает аварийное завершение при ошибке.",
        "theme" : "Разное"
    },
    {
        "id": "142",
        "question": "Что такое сырые строки (raw strings)?",
        "answer": "Сырые строки (raw strings) - это строки, в которых все символы интерпретируются буквально, включая символы новой строки и табуляции. Они объявляются с использованием символов # перед началом и концом строки, например, let rawString = #\"This is a raw string with \\n and \\t\"#.",
        "theme" : "Разное"
    },
    {
        "id": "143",
        "question": "Что делает директива компилятора #error?",
        "answer": "Директива компилятора #error в языке Swift используется для генерации ошибки на этапе компиляции при выполнении определенного условия или для внедрения пользовательских сообщений об ошибках в код. Когда компилятор встречает #error, он останавливает компиляцию и выводит сообщение об ошибке, указанное в директиве.",
        "theme" : "Разное"
    },
    {
        "id": "144",
        "question": "Что делает функция assert()?",
        "answer": "Функция assert() в Swift используется для добавления проверок (условий) в ваш код с целью обнаружения и обработки ошибок или некорректных состояний.",
        "theme" : "Разное"
    },
    {
        "id": "145",
        "question": "Что делает ключевое слово final, и почему вы можете его использовать?",
        "answer": "Ключевое слово final в Swift используется для пометки класса, метода или свойства как 'окончательного' (final), что означает, что они не могут быть переопределены или наследованы другими классами.",
        "theme" : "Разное"
    },
    {
        "id": "146",
        "question": "Для чего предназначена подпись кода (code signing) в Xcode?",
        "answer": "Подпись кода (code signing) в Xcode предназначена для обеспечения безопасности и целостности вашего приложения и позволяет ему успешно запускаться на устройствах и публиковаться в магазинах приложений.",
        "theme" : "Разное"
    },
    {
        "id": "147",
        "question": "Какова цель NotificationCenter?",
        "answer": "NotificationCenter в Swift используется для обмена сообщениями и уведомлениями между различными частями вашего приложения. Он предоставляет следующие цели и преимущества:\n\n1. Разделение данных: Позволяет разделить данные и функциональность между различными частями приложения, уменьшая связность.\n2. Отправка уведомлений: Позволяет объектам уведомлять о событиях или изменениях в приложении, чтобы другие объекты могли на них реагировать.\n3. Разработка слабосвязанных компонентов: Упрощает создание компонентов, которые могут взаимодействовать между собой без явных зависимостей.\n4. Реализация паттерна 'Наблюдатель' (Observer): Позволяет создавать паттерн 'Наблюдатель', где один объект наблюдает за изменениями в другом объекте и реагирует на них.\n5. Реакция на системные уведомления: Может использоваться для реагирования на системные уведомления, такие как изменение ориентации устройства или изменение статуса сети.",
        "theme" : "Разное"
    },
    {
        "id": "148",
        "question": "Какие различные способы отображения веб-контента перед пользователями?",
        "answer": "Один из способов отображения веб-контента перед пользователями в iOS - это использование SFSafariViewController. Этот контроллер позволяет открывать веб-страницы внутри приложения с использованием механизма Safari, обеспечивая удобство и безопасность для пользователей.",
        "theme" : "Разное"
    },
    {
        "id": "149",
        "question": "Каково отличие между типами данных Float, Double и CGFloat?",
        "answer": "1. Float: Это 32-битный тип с плавающей запятой, используемый для представления чисел с плавающей запятой одинарной точности. Он менее точен и может обрабатывать меньший диапазон значений, чем Double.\n\n2. Double: Это 64-битный тип с плавающей запятой, предназначенный для представления чисел с плавающей запятой двойной точности. Double более точен и способен обрабатывать более широкий диапазон значений, чем Float.\n\n3. CGFloat: Это платформозависимый тип, который представляет числа с плавающей запятой и автоматически адаптируется к аппаратной архитектуре (32-битная или 64-битная) вашего устройства. Он часто используется в разработке для обеспечения переносимости кода между разными платформами.",
        "theme" : "Разное"
    },
    {
        "id": "150",
        "question": "Что такое UUID и когда бы вы его использовали?",
        "answer": "UUID (Универсальный уникальный идентификатор) - это 128-битное число, которое представляет собой уникальный идентификатор. UUID используется для гарантированного уникального идентификации объектов или сущностей. Вы могли бы использовать UUID, например, для идентификации пользователей, устройств, файлов или других сущностей в вашем приложении или на сервере. Это обеспечивает уникальность и устойчивость идентификации в различных контекстах.",
        "theme" : "Разное"
    },
    {
        "id": "151",
        "question": "RunTime и CompileTime",
        "answer": "Compile Time: Это фаза разработки, где вы пишете, проверяете и компилируете код до запуска программы. Ошибки обнаруживаются здесь на этапе компиляции.\nRun Time: Это фаза, когда ваша программа запущена и работает, выполняя задачи в соответствии с вашим кодом. Ошибки времени выполнения могут возникнуть во время выполнения программы и обычно требуют отладки.",
        "theme" : "Разное"
    },
    {
        "id": "152",
        "question": "Чем Point (pt) отличается от Pixel (px)?",
        "answer": "Разница между ними заключается в том, что point абстрагирует разрешение экрана и позволяет создавать интерфейс, который выглядит одинаково на разных устройствах, а pixel является фактической единицей разрешения экрана. Важно использовать point для размеров элементов пользовательского интерфейса и pixel для графических ресурсов, чтобы обеспечить корректное отображение на разных устройствах.",
        "theme" : "Разное"
    },
    {
        "id": "153",
        "question": "Что такое Generics?",
        "answer": "Generics - это концепция, которая позволяет создавать универсальные (generic) функции и типы, которые могут работать с разными типами данных, сохраняя безопасность типов. Это позволяет избегать дублирования кода и создавать более гибкие и повторно используемые компоненты.",
        "theme" : "Разное"
    },
    {
        "id": "154",
        "question": "Что такое Autolayout?",
        "answer": "Auto Layout - это механизм размещения и управления расположением элементов интерфейса в приложениях, разработанный для обеспечения адаптивности и масштабируемости пользовательского интерфейса на разных устройствах и в разных ориентациях экрана.",
        "theme" : "Разное"
    },
    {
        "id": "155",
        "question": "Что такое typealias в Swift?",
        "answer": "typealias в Swift - это ключевое слово, которое используется для создания алиасов (псевдонимов) для существующих типов данных, включая пользовательские типы данных. Он позволяет использовать более краткие и понятные имена для типов, что может сделать код более читаемым.",
        "theme" : "Разное"
    },
    {
        "id": "156",
        "question": "В чем разница между уровнем доступа Fileprivate и Private?",
        "answer": "Основное различие между fileprivate и private заключается в том, что fileprivate расширяет видимость до всех типов в том же файле, в то время как private ограничивает видимость только внутри самого типа.",
        "theme" : "Разное"
    },
    {
        "id": "157",
        "question": "Определите функцию обратного вызова (completion handler).",
        "answer": "Функция обратного вызова (completion handler) - это замыкание (closure) в Swift, которое передается как аргумент в другую функцию и выполняется после завершения выполнения этой функции. Она позволяет асинхронным операциям сообщить о завершении и передать результаты вызывающему коду. Типичное использование функции обратного вызова - обработка завершения сетевого запроса, анимации, загрузки данных и других асинхронных задач.",
        "theme" : "Разное"
    },
    {
        "id": "158",
        "question": "Как используется оператор Switch Statement в языке Swift?",
        "answer": "Оператор switch в Swift используется для выполнения различных действий в зависимости от значения выражения или переменной.",
        "theme" : "Разное"
    },
    {
        "id": "159",
        "question": "Для чего используется оператор break в языке Swift?",
        "answer": "Оператор break в языке Swift используется для прерывания выполнения цикла или выхода из блока switch.",
        "theme" : "Разное"
    },
    {
        "id": "160",
        "question": "Объясните, что такое NSUserDefaults? Какие типы поддерживает NSUserDefaults?",
        "answer": "NSUserDefaults в iOS и macOS - это механизм для хранения пользовательских настроек и других небольших данных в виде пар 'ключ-значение'. Он представляет собой объект типа UserDefaults и обеспечивает доступ к файлу конфигурации для приложения. Наиболее распространенное использование NSUserDefaults - это сохранение настроек пользователя, таких как предпочтенный язык приложения, уровень громкости, или флаги, которые включают или выключают определенные функции. NSUserDefaults поддерживает следующие типы данных: String, Integer, Double, Float, Bool, Data, URL.",
        "theme" : "Разное"
    },
    {
        "id": "161",
        "question": "Для какой цели используется reuseIdentifier?",
        "answer": "reuseIdentifier используется в разработке iOS для повторного использования ячеек таблиц и элементов коллекций.",
        "theme" : "Разное"
    },
    {
        "id": "162",
        "question": "Объясните деинициализатор (de-initializer) и как его пишут на Swift?",
        "answer": "Деинициализатор (deinitializer) в Swift - это специальный метод, который вызывается при уничтожении экземпляра класса, чтобы выполнить необходимую очистку ресурсов или другие завершающие действия. Деинициализатор пишется с использованием ключевого слова 'deinit', за которым следует блок кода для освобождения ресурсов и выполнения других завершающих операций.",
        "theme" : "Разное"
    },
    {
        "id": "163",
        "question": "Укажите разницу между 'app ID' и 'bundle ID'. Зачем они используются?",
        "answer": "\"Bundle ID\" (идентификатор пакета) - это уникальный идентификатор вашего приложения в рамках одного приложения. Он используется для идентификации вашего приложения внутри устройства и App Store.\n\n\"App ID\" (идентификатор приложения) - это уникальный идентификатор, который связан с вашим приложением и используется для взаимодействия с различными службами Apple, такими как службы уведомлений, пуш-уведомления и другие. Он также используется для настройки профиля подписи и конфигурации приложения.",
        "theme" : "Разное"
    },
    {
        "id": "164",
        "question": "Что означает глубокая ссылка (Deep linking) в iOS?",
        "answer": "Глубокая ссылка (Deep linking) в iOS - это технология, позволяющая перенаправлять пользователя на конкретное место в мобильном приложении в ответ на действия или переходы извне приложения. Глубокая ссылка обычно содержит информацию о действии, которое должно быть выполнено внутри приложения, и может включать параметры или контекст для этого действия.",
        "theme" : "Разное"
    },
    {
        "id": "165",
        "question": "Объясните разницу между KVC и KVO в Swift.",
        "answer": "KVC (Key-Value Coding) позволяет получать и устанавливать значения свойств объектов по их ключам (именам свойств) с использованием методов и строковых ключей. KVO (Key-Value Observing) позволяет наблюдать (следить) за изменениями свойств объекта. Когда свойство объекта меняется, KVO уведомляет наблюдателей о произошедших изменениях.",
        "theme" : "Разное"
    },
    {
        "id": "166",
        "question": "Какие есть виды провижн профайлов",
        "answer": "В контексте разработки для платформы iOS, провижн профайлы (provisioning profiles) используются для обеспечения безопасности и управления приложениями в процессе разработки и распространения. Вот некоторые из видов провижн профайлов в Swift:\n\n1. Development Provisioning Profile (Профайл разработки): Используется для разработки и отладки приложения на устройствах разработчика.\n2. Distribution Provisioning Profile (Профайл распространения): Используется для распространения приложения через App Store или другие методы.\n3. Ad Hoc Provisioning Profile (Профайл для ограниченного круга пользователей): Используется для распространения приложения среди ограниченной группы пользователей для тестирования перед выпуском в App Store.\n4. App Store Provisioning Profile (Профайл для App Store): Используется для подписи и распространения приложения через App Store.\n5. In-House Provisioning Profile (Профайл для корпоративного использования): Используется компаниями для распространения приложений среди сотрудников без публикации в App Store.",
        "theme" : "Разное"
    },
    {
        "id": "167",
        "question": "В чем разница между Any Object и Generics?",
        "answer": "Разница заключается в том, что AnyObject работает с объектами на этапе выполнения, в то время как Generics обеспечивает безопасность типов на этапе компиляции и позволяет создавать обобщенные структуры и функции.",
        "theme" : "Разное"
    },
    {
        "id": "168",
        "question": "Что такое система контроля версий? Какие СКВ вам еще известны и используются на практике?",
        "answer": "Система контроля версий (СКВ) - это инструмент для управления и отслеживания изменений в исходном коде и файловой системе. Некоторые из известных и используемых СКВ на практике включают Git, GitHub, GitLab и Mercurial.",
        "theme" : "Разное"
    },
    {
        "id": "169",
        "question": "Что такое push, pull, fetch? Для чего нужен .gitignore файл?",
        "answer": "Push - отправка изменений из локального репозитория на удаленный сервер. Pull - получение изменений с удаленного сервера и объединение их с локальными. Fetch - получение изменений с удаленного сервера без их автоматического объединения с локальными изменениями. .gitignore файл нужен для указания файлов и директорий, которые не должны быть отслеживаемыми в системе контроля версий Git.",
        "theme" : "Разное"
    },
    {
        "id": "170",
        "question": "Что делает init() в Swift?",
        "answer": "Метод init() в Swift выполняет начальную настройку объекта, выделяет память и инициализирует его свойства.",
        "theme" : "Разное"
    },
    {
        "id": "171",
        "question": "Для чего нужен оператор вида «??»?",
        "answer": "Оператор ?? (nil-coalescing operator) используется для предоставления значения по умолчанию, если левый операнд является nil. Например, a ?? b вернет значение a, если оно не равно nil, иначе вернет значение b.",
        "theme" : "Разное"
    },
    {
        "id": "172",
        "question": "Можно ли задать параметру функции значение по умолчанию?",
        "answer": "Да, в Swift можно задать параметру функции значение по умолчанию, что делает его необязательным при вызове функции.",
        "theme" : "Разное"
    },
    {
        "id": "173",
        "question": "В чем разница между операторами == и ===?",
        "answer": "Оператор == используется для сравнения двух объектов на равенство и сравнивает их содержимое. Оператор === используется для проверки тождественности двух объектов, то есть они должны указывать на один и тот же экземпляр объекта.",
        "theme" : "Разное"
    },
    {
        "id": "174",
        "question": "Что такое ассоциированное значение?",
        "answer": "Ассоциированное значение (Associated Value) - это концепция в языке программирования Swift, используемая с перечислениями (enum). Она позволяет связывать дополнительные значения или данные с конкретным случаем перечисления.",
        "theme" : "Разное"
    }
]
